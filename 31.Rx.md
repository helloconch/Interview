###RXJava2(注意与RXJava1区别)
[简书关于RxJava2](http://www.jianshu.com/p/464fa025229e)
#####使用create创建一个Observable
```
              //生成
		Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {

			@Override
			public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
				for (int i = 0; i < 10; i++) {
					observableEmitter.onNext(i);
				}

				observableEmitter.onComplete();
			}
		});
		//订阅
		
		observable.subscribe(new Observer<Integer>(){

			@Override
			public void onComplete() {
				System.out.println("onComplete");
			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");
			}

			@Override
			public void onNext(Integer arg0) {
				System.out.println("onNext------:"+arg0);
			}

			@Override
			public void onSubscribe(Disposable disponsable) {
			        //加上disponsable.disponse()则其它回调不执行				
                              System.out.println("onSubscribe");
			}
			
		});
    
    //简易订阅
    Disposable subscribe = observableData.subscribe(new Consumer<Integer>() {

			@Override
			public void accept(Integer arg0) throws Exception {
				System.out.println("Consumer accept:" + arg0);
			}

		});
		if (subscribe.isDisposed()) {
			System.out.println("-------ok------------");
		}
    
```
#####使用fromArray/fromFuture等创建Observable
```
List<Integer> items = new ArrayList<Integer>();
items.add(1);
items.add(10);
items.add(100);
items.add(200);

Observable<List<Integer>> observableData = Observable.fromArray(items);

observableData.subscribe（.......）
//Observable.fromFuture()
		Thread1 t = new Thread1();
		FutureTask<Integer> future = new FutureTask<Integer>(t);
		new Thread(future).start();
		Observable<Integer> fromFuture = Observable.fromFuture(future, 3, TimeUnit.SECONDS);

		fromFuture.subscribe(new Observer<Integer>() {

			@Override
			public void onComplete() {
				System.out.println("onComplete");

			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");

			}

			@Override
			public void onNext(Integer arg0) {
				System.out.println("onNext:" + arg0);

			}

			@Override
			public void onSubscribe(Disposable disposable) {

				System.out.println("onSubscribe :" + disposable.isDisposed());
			}
		});

```
#####Observable.just()方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们
```
	     Observable<String> observable = Observable.just(helloWorld(), helloBJ());
	     
	     observable.subscribe(new Observer<String>(){

			@Override
			public void onComplete() {
				System.out.println("onComplete");
			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");
			}

			@Override
			public void onNext(String arg0) {
				System.out.println("onNext"+arg0);
				
			}

			@Override
			public void onSubscribe(Disposable arg0) {
				System.out.println("onSubscribe");
				
			}
	    	 
	     });
	     
	   }
	   
	   private static String helloWorld(){
	    return "Hello World";
	   }
	   
	   private static String helloBJ(){
	   return "Hello BeiJing";
	   }
```
#####PublishSubject/BehaviorSubject/ReplaySubject/AsyncSubject
```
BehaviorSubject

简单的说，BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。
ReplaySubject

ReplaySubject会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发
AsyncSubject

当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。

PublishSubject<Boolean> publishSubject = PublishSubject.create();

		publishSubject.subscribe(new Observer<Boolean>() {

			@Override
			public void onComplete() {
			System.out.println("onComplete");

			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");

			}

			@Override
			public void onNext(Boolean arg0) {
				System.out.println("onNext:"+arg0);
			}

			@Override
			public void onSubscribe(Disposable arg0) {
				System.out.println("onSubscribe:"+arg0);

			}

		});

		Observable.create(new ObservableOnSubscribe<Integer>() {

			@Override
			public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
				for (int i = 0; i < 5; i++) {
					observableEmitter.onNext(i);
				}
				observableEmitter.onComplete();
			}
		}).doOnComplete(new Action() {

			@Override
			public void run() throws Exception {
				publishSubject.onNext(true);
			}
		}).subscribe();

	}
```
#####just/repeat/defer/range/interval
```
repeat()

假如你想对一个Observable重复发射三次数据
defer()

有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。
range()

你需要从一个指定的数字X开始发射N个数字吗？你可以用range

interval()

interval()函数在你需要创建一个轮询程序时非常好用

timer()

如果你需要一个一段时间之后才发射的Observable，你可以像下面的例子使用timer()

```
#####过滤序列
```
filter()方法来过滤我们观测序列中不想要的值，在上一章中，我们在几个例子中使用了已安装的应用列表，但是我们只想展示以字母C开头的已安装的应用该怎么办呢？在这个新的例子中，我们将使用同样的列表，但是我们会过滤它，通过把合适的谓词传给filter()函数来得到我们想要的值。

```
#####获取我们需要的数据
```
当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用take()或takeLast()。
```
#####有且仅有一次
```
一个可观测序列会在出错时重复发射或者被设计成重复发射。distinct()和distinctUntilChanged()函数可以方便的让我们处理这种重复问题。
Distinct

如果我们想对一个指定的值仅处理一次该怎么办？我们可以对我们的序列使用distinct()函数去掉重复的。

DistinctUntilsChanged

如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？我们猜想一下我们观测的温度传感器，每秒发射的室内温度：
21°...21°...21°...21°...22°...
每次我们获得一个新值，我们都会更新当前正在显示的温度。我们出于系统资源保护并不想在每次值一样时更新数据。我们想忽略掉重复的值并且在温度确实改变时才想得到通知。ditinctUntilChanged()过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。
下图用图形化的方式展示了我们如何将distinctUntilChanged()函数应用在一个存在的序列上来创建一个新的不重复发射元素的序列。
```
#####First and last
```
```
#####Skip and SkipLast
```
```
#####ElementAt
```
elementAt()函数仅从一个序列中发射第n个元素然后就完成了。
```
#####Sampling
```
在Observable后面加一个sample()，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值
```
#####Timeout
```
我们工作的是一个时效性的环境，我们温度传感器每秒都在发射一个温度值。我们想让它每隔两秒至少发射一个，我们可以使用timeout()函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为timeout()为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发onError()函数
```
#####Debounce
```
```
#####map家族
```
RxJava的map函数接收一个指定的Func对象然后将它应用到每一个由Observable发射的值上.
 Observable observableData = Observable.just("A", "B", "C", "D");
        show(observableData.map(new Function() {
            @Override
            public Object apply(Object o) throws Exception {
                return o.toString().toLowerCase();
            }
        }));
```
#####FlatMap
```
在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。
当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况，flatMap()将会触发它自己的onError()函数并放弃整个链。
重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。

```
#####ConcatMap
```
RxJava的concatMap()函数解决了flatMap()的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数
```
#####FlatMapIterable
```
作为*map家族的一员，flatMapInterable()和flatMap()很像。仅有的本质不同是它将源数据两两结成对并生成Iterable，而不是原始数据项和生成的Observables。
```
#####SwitchMap
```
switchMap()和flatMap()很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。
```
#####Scan
```
RxJava的scan()函数可以看做是一个累积函数。scan()函数对原始Observable发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。
  show( observableData2.scan(new BiFunction() {
            @Override
            public Object apply(Object o, Object o2) throws Exception {
                return Integer.parseInt(o.toString())+Integer.parseInt(o2.toString());
            }
        }));
```
#####GroupBy
```
```
#####Schedulers
```
Schedulers.io()

这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的StrictMode违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。
重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。
Schedulers.computation()

这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器：buffer(),debounce(),delay(),interval(),sample(),skip()。
Schedulers.immediate()

这个调度器允许你立即在当前线程执行你指定的工作。它是timeout(),timeInterval(),以及timestamp()方法默认的调度器。
Schedulers.newThread()

这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。
Schedulers.trampoline()

当我们想在当前线程执行一个任务时，并不是立即，我们可以用.trampoline()将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是repeat()和retry()方法默认的调度器。


```
#####非阻塞I/O操作
```
 Schedulers.io().createWorker().schedule(() -> {
        blockingStoreBitmap(context, bitmap, filename);
    });
```
#####SubscribeOn and ObserveOn
```
RxJava提供了subscribeOn()方法来用于每个Observable对象。subscribeOn()方法用Scheduler来作为参数并在这个Scheduler上执行Observable调用。

getApps()
.onBackpressureBuffer()
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer<AppInfo>() { [...]

onBackpressureBuffer()方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。
```
#####处理耗时的任务
```
getObservableApps(apps)
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.computation())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer<AppInfo>() { [...]
```
#####执行网络任务
```
1.下载进度观察者
2.下载方法实现
3.下载观察者
4.订阅下载进度
5.订阅下载




首先，我们创建mDownloadProgress
private PublishSubject<Integer> mDownloadProgress = PublishSubject.create();
这个主题我们用来管理进度的更新，它和download函数协同工作。
private boolean downloadFile(String source, String destination) {
    boolean result = false;
    InputStream input = null; 
    OutputStream output = null; 
    HttpURLConnection connection = null;
    try {
        URL url = new URL(source);
        connection = (HttpURLConnection) url.openConnection(); 
        connection.connect();
        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            return false;
        }
        int fileLength = connection.getContentLength();
        input = connection.getInputStream();
        output = new FileOutputStream(destination);
        byte data[] = new byte[4096];
        long total = 0;
        int count;
        while ((count = input.read(data)) != -1) {
            total += count;
            if (fileLength >0) {
                int percentage = (int) (total * 100 / fileLength);
                mDownloadProgress.onNext(percentage);
            }
            output.write(data, 0, count); 
        }
        mDownloadProgress.onCompleted(); 
        result = true;
    } catch (Exception e) { 
        mDownloadProgress.onError(e);
    } finally { 
        try {
            if (output != null) { 
                output.close();
            }
            if (input != null) {
                input.close(); 
            }
        } catch (IOException e) {    
            mDownloadProgress.onError(e);
        }
        if (connection != null) {
            connection.disconnect();
            mDownloadProgress.onCompleted();
        }
    }
    return result;
}
上面的这段代码将会触发NetworkOnMainThreadException异常。我们可以创建RxJava版本的函数进入我们挚爱的响应式世界来解决这个问题：
private Observable<Boolean> obserbableDownload(String source, String destination) {
    return Observable.create(subscriber -> {
        try {
            boolean result = downloadFile(source, destination); 
            if (result) {
                subscriber.onNext(true);
                subscriber.onCompleted(); 
            } else {
                subscriber.onError(new Throwable("Download failed."));
            }
        } catch (Exception e) { 
            subscriber.onError(e);
        } 
    });
}
现在我们需要触发下载操作，点击下载按钮:
@OnClick(R.id.button_download)
void download() {
    mButton.setText(getString(R.string.downloading));
    mButton.setClickable(false);
    mDownloadProgress.distinct()
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer<Integer>() {

        @Override
        public void onCompleted() {  
            App.L.debug("Completed");
        }

        @Override
        public void onError(Throwable e) {
            App.L.error(e.toString()); 
        }

        @Override
        public void onNext(Integer progress) {
            mArcProgress.setProgress(progress);
        } 
    });

    String destination = "sdcardsoftboy.avi";
    obserbableDownload("http://archive.blender.org/fileadmin/movies/softboy.avi", destination)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(success -> {
            resetDownloadButton();
            Intent intent = new Intent(android.content.Intent.ACTION_VIEW);
            File file = new File(destination);
            intent.setDataAndType(Uri.fromFile(file),"video/avi");
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 
            startActivity(intent);
        }, error -> {
            Toast.makeText(getActivity(), "Something went south", Toast.LENGTH_SHORT).show();
            resetDownloadButton();
        });
}
我们使用Butter Knife的注解@OnClick来绑定按钮的方法并更新按钮信息和点击状态：我们不想让用户点击多次从而触发多次下载事件。
然后，我们创建一个subscription来观察下载进度并相应的更新进度条。很明显，我们订阅在主线程是因为进度条是UI元素。
obserbableDownload("http://archive.blender.org/fileadmin/movies/softboy.avi", "sdcardsoftboy.avi";)
这是一个下载Observable。网络调用是一个I/O任务，理应使用I/O调度器。当下载完成，就会在onNext() 中启动视频播放器，并且播放器将会在目标路径找到下载的文件.。
```
#####ViewObservable
```
```
#####WidgetObservable 
```
```
##### LifecycleObservable
```
```
