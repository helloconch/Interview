###RXJava2(注意与RXJava1区别)
#####使用create创建一个Observable
```
              //生成
		Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {

			@Override
			public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
				for (int i = 0; i < 10; i++) {
					observableEmitter.onNext(i);
				}

				observableEmitter.onComplete();
			}
		});
		//订阅
		
		observable.subscribe(new Observer<Integer>(){

			@Override
			public void onComplete() {
				System.out.println("onComplete");
			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");
			}

			@Override
			public void onNext(Integer arg0) {
				System.out.println("onNext------:"+arg0);
			}

			@Override
			public void onSubscribe(Disposable disponsable) {
			        //加上disponsable.disponse()则其它回调不执行				
                              System.out.println("onSubscribe");
			}
			
		});
    
    //简易订阅
    Disposable subscribe = observableData.subscribe(new Consumer<Integer>() {

			@Override
			public void accept(Integer arg0) throws Exception {
				System.out.println("Consumer accept:" + arg0);
			}

		});
		if (subscribe.isDisposed()) {
			System.out.println("-------ok------------");
		}
    
```
#####使用fromArray/fromFuture等创建Observable
```
List<Integer> items = new ArrayList<Integer>();
items.add(1);
items.add(10);
items.add(100);
items.add(200);

Observable<List<Integer>> observableData = Observable.fromArray(items);

observableData.subscribe（.......）
//Observable.fromFuture()
		Thread1 t = new Thread1();
		FutureTask<Integer> future = new FutureTask<Integer>(t);
		new Thread(future).start();
		Observable<Integer> fromFuture = Observable.fromFuture(future, 3, TimeUnit.SECONDS);

		fromFuture.subscribe(new Observer<Integer>() {

			@Override
			public void onComplete() {
				System.out.println("onComplete");

			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");

			}

			@Override
			public void onNext(Integer arg0) {
				System.out.println("onNext:" + arg0);

			}

			@Override
			public void onSubscribe(Disposable disposable) {

				System.out.println("onSubscribe :" + disposable.isDisposed());
			}
		});

```
#####Observable.just()方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们
```
	     Observable<String> observable = Observable.just(helloWorld(), helloBJ());
	     
	     observable.subscribe(new Observer<String>(){

			@Override
			public void onComplete() {
				System.out.println("onComplete");
			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");
			}

			@Override
			public void onNext(String arg0) {
				System.out.println("onNext"+arg0);
				
			}

			@Override
			public void onSubscribe(Disposable arg0) {
				System.out.println("onSubscribe");
				
			}
	    	 
	     });
	     
	   }
	   
	   private static String helloWorld(){
	    return "Hello World";
	   }
	   
	   private static String helloBJ(){
	   return "Hello BeiJing";
	   }
```
#####PublishSubject/BehaviorSubject/ReplaySubject/AsyncSubject
```
BehaviorSubject

简单的说，BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。
ReplaySubject

ReplaySubject会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发
AsyncSubject

当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。

PublishSubject<Boolean> publishSubject = PublishSubject.create();

		publishSubject.subscribe(new Observer<Boolean>() {

			@Override
			public void onComplete() {
			System.out.println("onComplete");

			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");

			}

			@Override
			public void onNext(Boolean arg0) {
				System.out.println("onNext:"+arg0);
			}

			@Override
			public void onSubscribe(Disposable arg0) {
				System.out.println("onSubscribe:"+arg0);

			}

		});

		Observable.create(new ObservableOnSubscribe<Integer>() {

			@Override
			public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
				for (int i = 0; i < 5; i++) {
					observableEmitter.onNext(i);
				}
				observableEmitter.onComplete();
			}
		}).doOnComplete(new Action() {

			@Override
			public void run() throws Exception {
				publishSubject.onNext(true);
			}
		}).subscribe();

	}
```
#####just/repeat/defer/range/interval
```
repeat()

假如你想对一个Observable重复发射三次数据
defer()

有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。
range()

你需要从一个指定的数字X开始发射N个数字吗？你可以用range

interval()

interval()函数在你需要创建一个轮询程序时非常好用

timer()

如果你需要一个一段时间之后才发射的Observable，你可以像下面的例子使用timer()

```
#####过滤序列
```
filter()方法来过滤我们观测序列中不想要的值，在上一章中，我们在几个例子中使用了已安装的应用列表，但是我们只想展示以字母C开头的已安装的应用该怎么办呢？在这个新的例子中，我们将使用同样的列表，但是我们会过滤它，通过把合适的谓词传给filter()函数来得到我们想要的值。

```
#####获取我们需要的数据
```
当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用take()或takeLast()。
```
#####有且仅有一次
```
一个可观测序列会在出错时重复发射或者被设计成重复发射。distinct()和distinctUntilChanged()函数可以方便的让我们处理这种重复问题。
Distinct

如果我们想对一个指定的值仅处理一次该怎么办？我们可以对我们的序列使用distinct()函数去掉重复的。

DistinctUntilsChanged

如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？我们猜想一下我们观测的温度传感器，每秒发射的室内温度：
21°...21°...21°...21°...22°...
每次我们获得一个新值，我们都会更新当前正在显示的温度。我们出于系统资源保护并不想在每次值一样时更新数据。我们想忽略掉重复的值并且在温度确实改变时才想得到通知。ditinctUntilChanged()过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。
下图用图形化的方式展示了我们如何将distinctUntilChanged()函数应用在一个存在的序列上来创建一个新的不重复发射元素的序列。
```
#####First and last
```
```
#####Skip and SkipLast
```
```
#####ElementAt
```
elementAt()函数仅从一个序列中发射第n个元素然后就完成了。
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
