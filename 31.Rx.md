###RXJava2
#####使用create创建一个Observable
```
              //生成
		Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {

			@Override
			public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
				for (int i = 0; i < 10; i++) {
					observableEmitter.onNext(i);
				}

				observableEmitter.onComplete();
			}
		});
		//订阅
		
		observable.subscribe(new Observer<Integer>(){

			@Override
			public void onComplete() {
				System.out.println("onComplete");
			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");
			}

			@Override
			public void onNext(Integer arg0) {
				System.out.println("onNext------:"+arg0);
			}

			@Override
			public void onSubscribe(Disposable disponsable) {
			        //加上disponsable.disponse()则其它回调不执行				
                              System.out.println("onSubscribe");
			}
			
		});
    
    //简易订阅
    Disposable subscribe = observableData.subscribe(new Consumer<Integer>() {

			@Override
			public void accept(Integer arg0) throws Exception {
				System.out.println("Consumer accept:" + arg0);
			}

		});
		if (subscribe.isDisposed()) {
			System.out.println("-------ok------------");
		}
    
```
#####使用fromArray/fromFuture等创建Observable
```
List<Integer> items = new ArrayList<Integer>();
items.add(1);
items.add(10);
items.add(100);
items.add(200);

Observable<List<Integer>> observableData = Observable.fromArray(items);

observableData.subscribe（.......）
//Observable.fromFuture()
		Thread1 t = new Thread1();
		FutureTask<Integer> future = new FutureTask<Integer>(t);
		new Thread(future).start();
		Observable<Integer> fromFuture = Observable.fromFuture(future, 3, TimeUnit.SECONDS);

		fromFuture.subscribe(new Observer<Integer>() {

			@Override
			public void onComplete() {
				System.out.println("onComplete");

			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");

			}

			@Override
			public void onNext(Integer arg0) {
				System.out.println("onNext:" + arg0);

			}

			@Override
			public void onSubscribe(Disposable disposable) {

				System.out.println("onSubscribe :" + disposable.isDisposed());
			}
		});

```
#####Observable.just()方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们
```
	     Observable<String> observable = Observable.just(helloWorld(), helloBJ());
	     
	     observable.subscribe(new Observer<String>(){

			@Override
			public void onComplete() {
				System.out.println("onComplete");
			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");
			}

			@Override
			public void onNext(String arg0) {
				System.out.println("onNext"+arg0);
				
			}

			@Override
			public void onSubscribe(Disposable arg0) {
				System.out.println("onSubscribe");
				
			}
	    	 
	     });
	     
	   }
	   
	   private static String helloWorld(){
	    return "Hello World";
	   }
	   
	   private static String helloBJ(){
	   return "Hello BeiJing";
	   }
```
#####PublishSubject/BehaviorSubject/ReplaySubject/AsyncSubject
```
BehaviorSubject

简单的说，BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。
ReplaySubject

ReplaySubject会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发
AsyncSubject

当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。

PublishSubject<Boolean> publishSubject = PublishSubject.create();

		publishSubject.subscribe(new Observer<Boolean>() {

			@Override
			public void onComplete() {
			System.out.println("onComplete");

			}

			@Override
			public void onError(Throwable arg0) {
				System.out.println("onError");

			}

			@Override
			public void onNext(Boolean arg0) {
				System.out.println("onNext:"+arg0);
			}

			@Override
			public void onSubscribe(Disposable arg0) {
				System.out.println("onSubscribe:"+arg0);

			}

		});

		Observable.create(new ObservableOnSubscribe<Integer>() {

			@Override
			public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
				for (int i = 0; i < 5; i++) {
					observableEmitter.onNext(i);
				}
				observableEmitter.onComplete();
			}
		}).doOnComplete(new Action() {

			@Override
			public void run() throws Exception {
				publishSubject.onNext(true);
			}
		}).subscribe();

	}
```
#####just/repeat/defer/range/interval
```
repeat()

假如你想对一个Observable重复发射三次数据
defer()

有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。
range()

你需要从一个指定的数字X开始发射N个数字吗？你可以用range

interval()

interval()函数在你需要创建一个轮询程序时非常好用

timer()

如果你需要一个一段时间之后才发射的Observable，你可以像下面的例子使用timer()

```
#####过滤序列
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
#####
```
```
