### 运行时数据区域
```
方法区:
与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，
静态变量，即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的
一个逻辑部分，它确有一个别名Non-Heap（非堆），目的应该是与Java堆区分开来。
很多人喜欢把方法区成为永久代，是因为HotSpot虚拟机将GC分代收集扩展至方法区，
但现在也有放弃永久代逐步改为采用Native Memory来实现方法区的规划。当方法区无法
满足内存分配将抛出OOM异常。

VM虚拟机栈（线程私有）：
每个方法在执行的时候会创建一个帧栈，用于存储局部
变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直至执行完成的过程，
就对应着一个帧栈在虚拟机栈中入栈到出栈的过程。
局部变量表存放编译器可知的各种基本数据类型、对象引用和returnAddress类型。
在java虚拟机规范中，对这个区域规定了2种异常状况：如果线程请求的栈深度大于
虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可动态扩展，
如果扩展时无法申请到足够的内存，抛出OOM异常。

本地方法栈：
与虚拟机栈的区别，虚拟机栈为虚拟机执行的java方法服务，而本地方法栈
则为虚拟机使用到Native服务。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError
和OutOfMemoryError.

堆Heap：
java堆是JVM管理内存最大的一块，java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配。
Java堆是垃圾收集器管理的主要区域。从【内存回收的角度】来看，由于现在收集器基本都采用
【分代收集算法】所以java堆中可以细分：新生代和老年代。在细致一点的有Eden空间，
From Survivor空间，To Survivor空间。
从【内存分配的角度】来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区TLAB.
根据java虚拟机规范，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
如果堆中无可用内存，且堆也无法再扩展时，会抛出OOM异常。

程序计数器（线程私有）:
是一块较小的内存空间，可以看作是当前线程所执行的字节码的
行号指示器。此内存区域是唯一一个Java虚拟机规范中没有规定任何OOM情况的区域。

```

### 对象
```
对象的创建：
java堆中内存是绝对规整的，这种分配方式为“指针碰撞”。
java堆中的内存并不是规整的，则这种分配方式为“空闲列表”。

对象的内存布局：
对象在内存中存储的布局分3块区域：对象头(Header)/实例数据(Instance Data)/对齐填充(padding)

对象的访问定位：
目前主流的访问方式使用句柄和直接指针两种。

```

### 垃圾收集器与分配策略
```
那些内存需要回收？
通过可达性分析来判定对象是否存活。
这种算法的基本思路是通过一系列的“GC Roots”的对象作为起始点，从这些节点开始向下搜索，
搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。
可作为GC Roots的对象：
1.虚拟机栈中引用的对象。
2.方法区中类静态属性引用的对象。
3.方法区中常量引用的对象
4.本地方法栈中JNI引用的对象。
要宣告一个对象死亡，需要经历2次标记过程，如果一个对象通过可达性分析发现没有与
GC Roots相连接的引用链，则将进行第一标记并且进行一次筛选，筛选的条件是此对象
是否有必要执行finalize()方法。
如果这个对象被判定为有必要执行finalize()方法，那么这个对象将被放置在F-Queue队列中，
由一个低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡最后一次机会，
稍候GC将对F-Queue中对象进行第二次小规模的标记。


垃圾回收算法
标记-清除算法、复制算法、标记-整理算法、分代算法。

什么时候回收?

如何回收？
垃圾收集器
Serial收集器：它只会使用一个CPU或一个单线程的收集器去完成垃圾收集工作。
ParNew收集器：是Serial收集器的多线程版本，使用多条线程进行垃圾收集。
Parallel Scavenge收集器：使用复制算法的收集器又是多线程收集器。
Serial Old收集器：是Serial收集器的老年代版本，同样是一个单线程收集器，
使用"标记-整理"算法。
Parallel Old收集器：是Parallel Scavenge收集器老年代版本使用多线程和“标记-整理”算法。
CMS收集器：是一种获取最短回收停顿时间为目标的收集器。
G1收集器：是当今收集器技术发展最前沿的成果之一，是一款面向服务端应用的垃圾收集器。



```
### java内存模型与线程
```
java虚拟机试图定义一种Java内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，
以实现让java程序在各种平台都能达到一致的内存访问效果。

java内存模型规定了所有的变量(实例字段、静态字段、构成数组对象的元素)都存储在主内存。
每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。
线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，而不能直接读写主内存中的变量。
不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存完成。

java线程-->工作内存--->Save和load操作--->主内存

java内存模型围绕着并发过程中如何处理原子性，可见性和有序性这3个特征来建立。

原子性

可见性：普通的变量与volatile变量区别，volatile的特殊规则保证了新值能立即同步到主内存，
以及每次使用前立即从主内存率先，可以说volatile保证了多线程操作时变量的可见性。除了volatile
,java还有2个关键字能实现可见性，即synchronized和final.

有序性：java语言提供了volatile和synchronized两个关键字来保证线程间操作的有序性，
volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则由一个变量在同一个时刻
只允许一条线程进行lock操作，这条规则决定了持有同一个锁的两个同步块只能串行的进入。



```

