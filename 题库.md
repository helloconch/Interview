### LruCache原理
[单一职责原则+开闭原则+LruCache实现ImageLoader](https://github.com/helloconch/Interview/tree/master/TIKU/app/src/main/java/com/conch/tiku/imageloader)


[原理详解](https://www.jianshu.com/p/b49a111147ee)
```
LRU(Least Recently Used)
LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。
LruCache内部使用LinkedHashMap进行数据存储,LinkedHashMap是由数组和双向链表的数据结构来实现。
双向链表结构可以实现访问顺序和插入顺序，使得LinkedHashMap<Key,Value>可以按照一定顺序排列起来。
通过构造函数 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
中的accessOrder区分是访问顺序还是插入顺序。accessOrder：true访问顺序，false为插入顺序。
LruCache中源码：
  public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }

put()方法，在添加缓存对象后，调用trimToSize()判断缓存是否已满，如果满了，则删除近期最少使用。
trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。
get()方法获取集合中缓存对象，将会更新队列，保持整个队列按照访问顺序排序。


```

### DiskLruCache解析
[详解](https://blog.csdn.net/guolin_blog/article/details/28863651)

### 图片加载原理
```
图片加载，首先是CPU计算出图像形状，完成之后，将图像交给GPU进行渲染，然后通过Dispay屏幕进行展示。
但是需要注意的一点，当CPU和GPU处理1帧图像时间超过16ms,那么这帧图像需要等到第2个VSync出现，
才能在屏幕进行显示，意味着32ms内所看到的是同1帧图像，产生所谓掉帧，也就是卡帧。

有几个因素使得CPU,GPU处理时间过长？
.过度绘制
2.动画使用次数过多
3.短时间创建对象过多（android垃圾回收机制，当heap被占用的空间达到一个阈值，GC开始回收对象，
GC回收时大部分线程是阻塞的，当GC耗时超过16ms，则出现失帧卡顿的现象）
```
### 模块化实现（好处、原因）
```
模块化是一种将复杂的系统分解为可管理模块的方式。
.模块间解耦(每个模块功能不同、业务逻辑不同、模块间业务解耦)
.提升开发效率(每个模块实际是一个项目，可以单独编译调试)
.多团队并行开发，测试。

模块化业务分层，从下到上
1.基础组件层(底层库和一些封装的libs)
2.业务组件层(支付、即时通信)
3.业务模块层(资讯模块、购物模块)


组件化是以重用化为目的，将一个系统拆分成一个个单独组件。
.避免重复造轮子，节省开发维护成本。
.降低项目复杂性，提升开发效率
.多个团队用同一个组件，在一定程度确保技术方案统一性。

```
### JVM
```
```
### 视频、文件加密传输

[详解](https://github.com/helloconch/Interview/blob/master/TIKU/app/src/main/java/com/conch/tiku/utils/FileEncryptAndDecrypt.java)

### 统计启动时长 标准
```
启动类型
1.冷启动，application没有被创建，需要先创建进程（fork一个新的进程，比较耗时），然后启动MainActivity.
2.热启动，已经启动过application,并驻留在系统内存内，只需要唤醒该进程，启动MainActivity

统计启动时间
1.物理统计：通过高速相机，从点击launcher图标开始，到MainActivity第一个可见帧，算启动时间
2.adb统计： adb shell am start -W package/xxx.MainActivity

启动流程：
1.点击桌面应用图标，launcher进程将启动的目标Activity的请求以Binder方式发送给AMS.
2.AMS收到请求后，以Socket方式请求Zygote进程
3.Zygote收到请求，fork出新进程。
4.在新进程中创建ActivityThread对象，新创建的进程就是应用的主线程，
在主线程里开启Looper消息循环，开始处理创建Activity
5.ActivityThread利用ClassLoader去加载Activity,创建Activity实例，并回调Activity
的onCreate().


```
### ThreadLocal原理
```
ThreadLocal用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)
时能保证各个线程里的变量相对独立于其他线程内的变量。

ThreadLocal设计思路：
每个ThreadLocal维护一个ThreadLocalMap映射表，这个映射表key为ThrealLocal本身，value是真正
需要存储的Object.

```
### 强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）
[详解](https://blog.csdn.net/mazhimazh/article/details/19752475)
### 谈谈classloader
```
jvm有三类classloader,分别为bootstrapclassloader,extendedclassloader以及systemclassloader.
bootstrap classloader是系统在启动jvm时默认加载的。
bootstrap classloader加载后，会载入extended classloader,并将extended classloader的父类
设为bootstrap classloader.
然后bootstrap classloader接着载入system classloader,并将system classloader父类设为extended 
classloader.至此bootstrap--extended--system三级继承结构形成。

类加载器的任务是将class二进制文件加载到方法区，供虚拟机模制出在堆中存放的对象。

classloader加载类的过程为：双亲委托机制
1.检查被加载类是否被加载
2.如果没有被加载，则调用父classloader加载该类。
3.如果1、2不成功，则由自身的类加载。
```
### 热修复，插件化
```
共同原理都是使用classloader来实现加载新的功能类，都可以使用PathClassloader与DexClassloader
不同是热修复是为了修复bug,将新的同名类替代同名的bug类。

插件化是增加新的功能或者资源文件，不涉及抢先加载旧的类这样的使用。

插件化比热修复简单，热修复是在插件化的基础上进行替换旧的Bug类。
```
### HashMap源码， SparseArray原理

[详解](https://www.jianshu.com/p/7b9a1b386265)
```
SparseArray采用2个数组，一个数组int[] mKeys存放key值，
因为key值为int，不需要hashcode操作，插入和查找基于二分法。
另一个数组int[] mValues存放值。

在数据量小的时候，一般为1000以下，当key值为int时候，使用SparseArray是一个不错
选择，相比较hashMap内存大概节省30% ,因为key值不需要进行装箱操作，所以性能较优。

```
### Collection的List ArrayList LinkedList
```
List(列表，线性顺序存储，可查找)
ArrayList（数组，中间插入删除慢，查找快）
LinkedList(链表，中间插入删除快，查找慢)

```
### map- HashMap Hashtable LinkedHashMap和TreeMap
```
HashMap：根据key的hashcode来存储数据，遍历时，取得数据随机，由于是线程不安全，
当需要同步时可用Collections.synchronizedMap()使HashMap具有同步能力，或者使用
ConcurrentHashMap，HashMap最多允许一条记录key=null,允许多条记录值为null.

HashTable:继承Dictionary类，线程安全，某一时刻只有一个线程写入，写入较慢，不允许键值为空.

LinkedHashMap：extends Hashmap，但它保存写入顺序，遍历时如果希望和写入顺序相同，可以考虑使用.

TreeMap:间接implements SortMap接口，能够把它保存的记录根据键排序，默认为升序排序，
也可以指定排序比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。


```

### HashMap、ConcurrentHashMap实现原理
[HashMap详解](http://www.importnew.com/16301.html)
[ConcurrentHashMap详解](https://blog.csdn.net/dingji_ping/article/details/51005799)

```
HashMap底层是一个数组结构，数组中的每一项是一个链表。
简单的说，HashMap在底层将key-value当成一个整体处理，这个整体就是一个Entry对象。HashMap
底层采用一个Entry[]数组来保存所有key-value对，当需要存储一个Entry对象时，会根据hash算法
来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置。

ConcurrentHashMap类创建16个并发的segment,每个segment里面包含多个Hash表，每个
Hash链都是有HashEntry节点组成。
HashTable是线程安全的，是因为将整张表加锁实现同步，一个缺陷是程序效率变得很低。
而ConcurrentHashMap将锁加在每个分段segment，这样我们队segment1操作的时候，
同时也可以对segment2的数据操作，这样效率会高很多。
```

### 性能优化，怎么保证应用启动不卡顿
[详解](https://blog.csdn.net/axi295309066/article/details/72675365)

```
应用在启动过程中，影响启动速度地方：
.Application的OnCreate
.首屏Activity的渲染

1.使用Traceview工具观察启动过程中方法耗时情况，重点关注onCreate()方法
2.分析自定义Application耗时操作，判断onCreate()方法中内容（如第三方工具是否可以不占用主线程进行初始化）
3.查看界面是否过度绘制
4.利用Hierarchy Viewer（层级）工具查看界面优化点
5.启动过程中的白屏优化
```

### 怎样去除重复代码
```
重构的主要任务是去除重复代码，有效的减少重复代码，提高软件的扩展性。
1.为项目定义一个基Activity或Fragment
2.代码的去重复技巧（如提炼方法，抽象基类）
3.用include减少局部布局重复
4.用ViewStub减少整体布局的重复

```
### 多进程共享数据方法
```
SharedPreferences(多进程模式)、广播、Socket、ContentProvider、Messenger、AIDL
Messager是一种轻量级IPC方案，底层实现原理就是AIDL，它对AIDL做了一次封装，它的效率比较低，
一次只能处理一次请求，所以不存在线程同步问题。
```

### SP是进程同步的吗？有什么方法做到同步
[详解](https://www.jianshu.com/p/bdebf741221e)
```
SP不能保证多进程间同步。
为了减少IO造成的性能损失，SP使用缓存机制，会将数据保持到内存中，
在读取的时候直接从内存获取，而写入的时候才保持到文件。如果多个进程都使用了普通的SP，
分别保存就会导致相互覆盖。

设置了MODE_MUTI_PROCESS之后，在多进程使用的时候，会在检测到文件变化时候，重新
加载文件到内存汇总，这样虽然损失一部分性能，却部分实现了多进程间同步。

为什么是部分实现多进程同步？当多个进程同时而又高频的调用commit方法时，就会导致文件
反复覆盖写入，而并没有被及时读取，造成进程间数据不同步。


通过ContentProvider进行实现多进程共享SP

```

### SurfaceView
[详解](https://blog.csdn.net/android_cmos/article/details/68955134)
```
SDK文档描述，SurfaceView就是在窗口里挖了一个洞，它显示在这个洞里，其他的View显示在
窗口上，所以view可以显示在surfaceview之上。surfaceview属于view的子类，是专门为制作
游戏产生，功能强大，最重要的是支付OPENGL ES库，2D,3D效果可以实现。创建SurfaceView时候
需要实现SurfaceHolder.Callback接口，它可以用来监听SurfaceView状态。

SurfaceView相当于另一个绘图线程，它是不会阻碍主线程，并且它在底层机制中实现双缓冲机制。


SurfaceView和View不同之处：
1.SurfaceView允许其它线程更新视图对象，而View不允许这么做，它只允许UI线程更新视图对象。
2.SurfaceView是放在其它最底层的视图层次中，所有其它视图都在它上面，所以在它之上可以添加一些层，
而且它不能是透明的。
3.它执行动画效率比View高，可以控制帧数。
4.SurfaceView在绘图的时使用双缓冲机制，而View没有。

```

### BroadcastReceiver、LocalBroadcastReceiver区别
```
BroadcastReceiver是跨应用广播，利用Binder机制实现。
LocalBroadcastReceiver是应用内广播，利用Handler实现，利用IntentFilter的match功能，
提供信息的发送与接收,效率比较高。

```


### Bundle机制
```
Bundle实现Parcelable接口，支持进程间通讯，保存特定数据。
```


### Handler机制
```
1.Handler通过sendMessage()发送消息message到消息队列MessageQueue.
2.Looper通过loop()不断提取触发条件message,并将message交给对应的target handler处理
3.target handler调用自身handleMessage()方法来处理Message

```


### Android事件传递机制
[详解](https://blog.csdn.net/carson_ho/article/details/54136311)
```
public boolean dispatchTouchEvent(MotionEvent ev){
  boolean consume = false;
  if(onInterceptTouchEvent(ev)){
      consume=onTouchEvent(ev);
 }else{
      consume=child.dispatchTouchEvent(ev);
  }
  return consume;
}
对于一个根ViewGroup来说，点击事件产生后，首先会调用它，这时它的dispatchTouchEvent就会调用，
如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示他要拦截当前事件，
接着这个ViewGroup的onTouchEvent方法就会调用
（这里默认它没设置OnTouchListener，具体为什么，这里先不讲），
如果onInterceptTouchEvent返回false，就表示它不拦截当前事件，
这时事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，
然后继续上述过程，直到事件被处理。


```


### java synchronized对象锁和类锁的区别
[详解](https://blog.csdn.net/zhujiangtaotaise/article/details/55509939)
```
synchronized加到static方法前面是给class加锁，即类锁。
1.对象锁和类锁是不同的锁，所以多个线程执行2个不同的锁的方法是，是异步操作。
2.类锁对该类的所有对象都能起作用，而对象锁不能。
```


### 动态加载、静态类加载
```
编译时加载是静态加载类。
运行时加载为动态加载类。
在日常中我们希望用到哪个就加载哪个，不用不加载，就需要动态加载类。
使用动态加载类时，我们不用定义100种功能，只需要通过实现某种标准（实现某个接口）。
public class Main{  
    public static void main(String args[]){  
        try{  
              
            Class c=Class.forName(args[0]);  
          
            All a=(All)c.newInstance();  
            a.start();  
        }catch(Exception e){  
            e.printStackTrace();  
        }  
    }  
}  
class A implements All{  
    public void start(){  
        System.out.println("A....START");  
    }  
}  
class B implements All{  
    public void start(){  
        System.out.println("B....START");  
    }  
}  
//接口  
interface All{  
    public void start();  
}

```


### GC回收策略
```
当系统空闲或者发起System.GC操作时，
从GC root开始搜索，搜索不到对象，经过第一次标记，清理后，仍然没有复活的对象。

```

### Android的大体架构图
```
Android系统架构图，从上往下
1.应用程序层
2.应用程序框架层
3.系统库和Android运行时
4.Linux内核
```

### Android Studio的build按钮后发生什么
```
build过程将资源和代码文件打包成apk
1.通过appt工具，将资源文件生成R.java文件，将aidl文件转化为对应java文件
2.编译java文件，生成.class文件
3.将.class文件转化为Android虚拟机支持的.dex文件
4.通过apkbuilder将dex文件和编译后的资源文件生成apk文件
5.对apk进行签名和对齐
```

### 大体说一下应用程序安装到手机发生了什么
```
1.复制apk到/data/app目录下，解压并扫描安装包
2.资源管理器解析apk里的资源文件
3.解析AndroidManifest清单文件，并在data/data/目录下创建对应的应用数据目录
4.对dex文件进行优化，并保持在dalvik-cache目录下
5.将AndroidManifest文件解析出的四大组件信息注册到PackManagerService中
6.安装完成后，发送广播

```

### Dalvik/ART 虚拟机有基本的了解
```
```
###
```
```

###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
