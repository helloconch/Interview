### LruCache原理
[单一职责原则+开闭原则+LruCache实现ImageLoader](https://github.com/helloconch/Interview/tree/master/TIKU/app/src/main/java/com/conch/tiku/imageloader)


[原理详解](https://www.jianshu.com/p/b49a111147ee)
```
LRU(Least Recently Used)
LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。
LruCache内部使用LinkedHashMap进行数据存储,LinkedHashMap是由数组和双向链表的数据结构来实现。
双向链表结构可以实现访问顺序和插入顺序，使得LinkedHashMap<Key,Value>可以按照一定顺序排列起来。
通过构造函数 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
中的accessOrder区分是访问顺序还是插入顺序。accessOrder：true访问顺序，false为插入顺序。
LruCache中源码：
  public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }

put()方法，在添加缓存对象后，调用trimToSize()判断缓存是否已满，如果满了，则删除近期最少使用。
trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。
get()方法获取集合中缓存对象，将会更新队列，保持整个队列按照访问顺序排序。


```

### DiskLruCache解析
[详解](https://blog.csdn.net/guolin_blog/article/details/28863651)

###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
