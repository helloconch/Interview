### LruCache原理
[单一职责原则+开闭原则+LruCache实现ImageLoader](https://github.com/helloconch/Interview/tree/master/TIKU/app/src/main/java/com/conch/tiku/imageloader)


[原理详解](https://www.jianshu.com/p/b49a111147ee)
```
LRU(Least Recently Used)
LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。
LruCache内部使用LinkedHashMap进行数据存储,LinkedHashMap是由数组和双向链表的数据结构来实现。
双向链表结构可以实现访问顺序和插入顺序，使得LinkedHashMap<Key,Value>可以按照一定顺序排列起来。
通过构造函数 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
中的accessOrder区分是访问顺序还是插入顺序。accessOrder：true访问顺序，false为插入顺序。
LruCache中源码：
  public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }

put()方法，在添加缓存对象后，调用trimToSize()判断缓存是否已满，如果满了，则删除近期最少使用。
trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。
get()方法获取集合中缓存对象，将会更新队列，保持整个队列按照访问顺序排序。


```

### DiskLruCache解析
[详解](https://blog.csdn.net/guolin_blog/article/details/28863651)

### 图片加载原理
```
图片加载，首先是CPU计算出图像形状，完成之后，将图像交给GPU进行渲染，然后通过Dispay屏幕进行展示。
但是需要注意的一点，当CPU和GPU处理1帧图像时间超过16ms,那么这帧图像需要等到第2个VSync出现，
才能在屏幕进行显示，意味着32ms内所看到的是同1帧图像，产生所谓掉帧，也就是卡帧。

有几个因素使得CPU,GPU处理时间过长？
.过度绘制
2.动画使用次数过多
3.短时间创建对象过多（android垃圾回收机制，当heap被占用的空间达到一个阈值，GC开始回收对象，
GC回收时大部分线程是阻塞的，当GC耗时超过16ms，则出现失帧卡顿的现象）
```
###模块化实现（好处、原因）
```
模块化是一种将复杂的系统分解为可管理模块的方式。
.模块间解耦(每个模块功能不同、业务逻辑不同、模块间业务解耦)
.提升开发效率(每个模块实际是一个项目，可以单独编译调试)
.多团队并行开发，测试。

模块化业务分层，从下到上
1.基础组件层(底层库和一些封装的libs)
2.业务组件层(支付、即时通信)
3.业务模块层(资讯模块、购物模块)


组件化是以重用化为目的，将一个系统拆分成一个个单独组件。
.避免重复造轮子，节省开发维护成本。
.降低项目复杂性，提升开发效率
.多个团队用同一个组件，在一定程度确保技术方案统一性。

```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
###
```
```
