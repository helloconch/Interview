### LruCache原理
[单一职责原则+开闭原则+LruCache实现ImageLoader](https://github.com/helloconch/Interview/tree/master/TIKU/app/src/main/java/com/conch/tiku/imageloader)


[原理详解](https://www.jianshu.com/p/b49a111147ee)
```
LRU(Least Recently Used)
LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。
LruCache内部使用LinkedHashMap进行数据存储,LinkedHashMap是由数组和双向链表的数据结构来实现。
双向链表结构可以实现访问顺序和插入顺序，使得LinkedHashMap<Key,Value>可以按照一定顺序排列起来。
通过构造函数 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
中的accessOrder区分是访问顺序还是插入顺序。accessOrder：true访问顺序，false为插入顺序。
LruCache中源码：
  public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }

put()方法，在添加缓存对象后，调用trimToSize()判断缓存是否已满，如果满了，则删除近期最少使用。
trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。
get()方法获取集合中缓存对象，将会更新队列，保持整个队列按照访问顺序排序。


```

### DiskLruCache解析
[详解](https://blog.csdn.net/guolin_blog/article/details/28863651)

### 图片加载原理
```
图片加载，首先是CPU计算出图像形状，完成之后，将图像交给GPU进行渲染，然后通过Dispay屏幕进行展示。
但是需要注意的一点，当CPU和GPU处理1帧图像时间超过16ms,那么这帧图像需要等到第2个VSync出现，
才能在屏幕进行显示，意味着32ms内所看到的是同1帧图像，产生所谓掉帧，也就是卡帧。

有几个因素使得CPU,GPU处理时间过长？
.过度绘制
2.动画使用次数过多
3.短时间创建对象过多（android垃圾回收机制，当heap被占用的空间达到一个阈值，GC开始回收对象，
GC回收时大部分线程是阻塞的，当GC耗时超过16ms，则出现失帧卡顿的现象）
```
### 模块化实现（好处、原因）
```
模块化是一种将复杂的系统分解为可管理模块的方式。
.模块间解耦(每个模块功能不同、业务逻辑不同、模块间业务解耦)
.提升开发效率(每个模块实际是一个项目，可以单独编译调试)
.多团队并行开发，测试。

模块化业务分层，从下到上
1.基础组件层(底层库和一些封装的libs)
2.业务组件层(支付、即时通信)
3.业务模块层(资讯模块、购物模块)


组件化是以重用化为目的，将一个系统拆分成一个个单独组件。
.避免重复造轮子，节省开发维护成本。
.降低项目复杂性，提升开发效率
.多个团队用同一个组件，在一定程度确保技术方案统一性。

```
### JVM
```
```
### 视频、文件加密传输

[详解](https://github.com/helloconch/Interview/blob/master/TIKU/app/src/main/java/com/conch/tiku/utils/FileEncryptAndDecrypt.java)

### 统计启动时长 标准
```
启动类型
1.冷启动，application没有被创建，需要先创建进程（fork一个新的进程，比较耗时），然后启动MainActivity.
2.热启动，已经启动过application,并驻留在系统内存内，只需要唤醒该进程，启动MainActivity

统计启动时间
1.物理统计：通过高速相机，从点击launcher图标开始，到MainActivity第一个可见帧，算启动时间
2.adb统计： adb shell am start -W package/xxx.MainActivity

启动流程：
1.点击桌面应用图标，launcher进程将启动的目标Activity的请求以Binder方式发送给AMS.
2.AMS收到请求后，以Socket方式请求Zygote进程
3.Zygote收到请求，fork出新进程。
4.在新进程中创建ActivityThread对象，新创建的进程就是应用的主线程，
在主线程里开启Looper消息循环，开始处理创建Activity
5.ActivityThread利用ClassLoader去加载Activity,创建Activity实例，并回调Activity
的onCreate().


```
### ThreadLocal原理
```
ThreadLocal用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)
时能保证各个线程里的变量相对独立于其他线程内的变量。

ThreadLocal设计思路：
每个ThreadLocal维护一个ThreadLocalMap映射表，这个映射表key为ThrealLocal本身，value是真正
需要存储的Object.

```
### 强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）
[详解](https://blog.csdn.net/mazhimazh/article/details/19752475)
### 谈谈classloader
```
jvm有三类classloader,分别为bootstrapclassloader,extendedclassloader以及systemclassloader.
bootstrap classloader是系统在启动jvm时默认加载的。
bootstrap classloader加载后，会载入extended classloader,并将extended classloader的父类
设为bootstrap classloader.
然后bootstrap classloader接着载入system classloader,并将system classloader父类设为extended 
classloader.至此bootstrap--extended--system三级继承结构形成。

类加载器的任务是将class二进制文件加载到方法区，供虚拟机模制出在堆中存放的对象。

classloader加载类的过程为：双亲委托机制
1.检查被加载类是否被加载
2.如果没有被加载，则调用父classloader加载该类。
3.如果1、2不成功，则由自身的类加载。
```
### 热修复，插件化
```
共同原理都是使用classloader来实现加载新的功能类，都可以使用PathClassloader与DexClassloader
不同是热修复是为了修复bug,将新的同名类替代同名的bug类。

插件化是增加新的功能或者资源文件，不涉及抢先加载旧的类这样的使用。

插件化比热修复简单，热修复是在插件化的基础上进行替换旧的Bug类。
```
### HashMap源码， SparseArray原理

[详解](https://www.jianshu.com/p/7b9a1b386265)
```
SparseArray采用2个数组，一个数组int[] mKeys存放key值，
因为key值为int，不需要hashcode操作，插入和查找基于二分法。
另一个数组int[] mValues存放值。

在数据量小的时候，一般为1000以下，当key值为int时候，使用SparseArray是一个不错
选择，相比较hashMap内存大概节省30% ,因为key值不需要进行装箱操作，所以性能较优。

```
### Collection的List ArrayList LinkedList
```
List(列表，线性顺序存储，可查找)
ArrayList（数组，中间插入删除慢，查找快）
LinkedList(链表，中间插入删除快，查找慢)

```
### map- HashMap Hashtable LinkedHashMap和TreeMap
```
HashMap：根据key的hashcode来存储数据，遍历时，取得数据随机，由于是线程不安全，
当需要同步时可用Collections.synchronizedMap()使HashMap具有同步能力，或者使用
ConcurrentHashMap，HashMap最多允许一条记录key=null,允许多条记录值为null.

HashTable:继承Dictionary类，线程安全，某一时刻只有一个线程写入，写入较慢，不允许键值为空.

LinkedHashMap：extends Hashmap，但它保存写入顺序，遍历时如果希望和写入顺序相同，可以考虑使用.

TreeMap:间接implements SortMap接口，能够把它保存的记录根据键排序，默认为升序排序，
也可以指定排序比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。


```
### 性能优化，怎么保证应用启动不卡顿
[详解](https://blog.csdn.net/axi295309066/article/details/72675365)

```
应用在启动过程中，影响启动速度地方：
.Application的OnCreate
.首屏Activity的渲染

1.使用Traceview工具观察启动过程中方法耗时情况，重点关注onCreate()方法
2.分析自定义Application耗时操作，判断onCreate()方法中内容（如第三方工具是否可以不占用主线程进行初始化）
3.查看界面是否过度绘制
4.利用Hierarchy Viewer（层级）工具查看界面优化点
5.启动过程中的白屏优化
```

### 怎样去除重复代码
```
重构的主要任务是去除重复代码，有效的减少重复代码，提高软件的扩展性。
1.为项目定义一个基Activity或Fragment
2.代码的去重复技巧（如提炼方法，抽象基类）
3.用include减少局部布局重复
4.用ViewStub减少整体布局的重复
5.多用引用

```

###
```
```

###
```
```

###
```
```


###
```
```


###
```
```


###
```
```


###
```
```


###
```
```


###
```
```

###
```
```

###
```
```
