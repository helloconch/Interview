### LruCache原理
[单一职责原则+开闭原则+LruCache实现ImageLoader](https://github.com/helloconch/Interview/tree/master/TIKU/app/src/main/java/com/conch/tiku/imageloader)


[原理详解](https://www.jianshu.com/p/b49a111147ee)
```
LRU(Least Recently Used)
LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。
LruCache内部使用LinkedHashMap进行数据存储,LinkedHashMap是由数组和双向链表的数据结构来实现。
双向链表结构可以实现访问顺序和插入顺序，使得LinkedHashMap<Key,Value>可以按照一定顺序排列起来。
通过构造函数 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
中的accessOrder区分是访问顺序还是插入顺序。accessOrder：true访问顺序，false为插入顺序。
LruCache中源码：
  public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }

put()方法，在添加缓存对象后，调用trimToSize()判断缓存是否已满，如果满了，则删除近期最少使用。
trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。
get()方法获取集合中缓存对象，将会更新队列，保持整个队列按照访问顺序排序。


```

### DiskLruCache解析
[详解](https://blog.csdn.net/guolin_blog/article/details/28863651)

### 图片加载原理
```
图片加载，首先是CPU计算出图像形状，完成之后，将图像交给GPU进行渲染，然后通过Dispay屏幕进行展示。
但是需要注意的一点，当CPU和GPU处理1帧图像时间超过16ms,那么这帧图像需要等到第2个VSync出现，
才能在屏幕进行显示，意味着32ms内所看到的是同1帧图像，产生所谓掉帧，也就是卡帧。

有几个因素使得CPU,GPU处理时间过长？
.过度绘制
2.动画使用次数过多
3.短时间创建对象过多（android垃圾回收机制，当heap被占用的空间达到一个阈值，GC开始回收对象，
GC回收时大部分线程是阻塞的，当GC耗时超过16ms，则出现失帧卡顿的现象）
```
### 模块化实现（好处、原因）
```
模块化是一种将复杂的系统分解为可管理模块的方式。
.模块间解耦(每个模块功能不同、业务逻辑不同、模块间业务解耦)
.提升开发效率(每个模块实际是一个项目，可以单独编译调试)
.多团队并行开发，测试。

模块化业务分层，从下到上
1.基础组件层(底层库和一些封装的libs)
2.业务组件层(支付、即时通信)
3.业务模块层(资讯模块、购物模块)


组件化是以重用化为目的，将一个系统拆分成一个个单独组件。
.避免重复造轮子，节省开发维护成本。
.降低项目复杂性，提升开发效率
.多个团队用同一个组件，在一定程度确保技术方案统一性。

```
### JVM
```
```
### 视频、文件加密传输

[详解](https://github.com/helloconch/Interview/blob/master/TIKU/app/src/main/java/com/conch/tiku/utils/FileEncryptAndDecrypt.java)

### 统计启动时长 标准
```
启动类型
1.冷启动，application没有被创建，需要先创建进程（fork一个新的进程，比较耗时），然后启动MainActivity.
2.热启动，已经启动过application,并驻留在系统内存内，只需要唤醒该进程，启动MainActivity

统计启动时间
1.物理统计：通过高速相机，从点击launcher图标开始，到MainActivity第一个可见帧，算启动时间
2.adb统计： adb shell am start -W package/xxx.MainActivity

启动流程：
1.点击桌面应用图标，launcher进程将启动的目标Activity的请求以Binder方式发送给AMS.
2.AMS收到请求后，以Socket方式请求Zygote进程
3.Zygote收到请求，fork出新进程。
4.在新进程中创建ActivityThread对象，新创建的进程就是应用的主线程，
在主线程里开启Looper消息循环，开始处理创建Activity
5.ActivityThread利用ClassLoader去加载Activity,创建Activity实例，并回调Activity
的onCreate().


```
### ThreadLocal原理
```
ThreadLocal用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)
时能保证各个线程里的变量相对独立于其他线程内的变量。

ThreadLocal设计思路：
每个ThreadLocal维护一个ThreadLocalMap映射表，这个映射表key为ThrealLocal本身，value是真正
需要存储的Object.

```
### 强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）
[详解](https://blog.csdn.net/mazhimazh/article/details/19752475)
### 谈谈classloader
```
jvm有三类classloader,分别为bootstrapclassloader,extendedclassloader以及systemclassloader.
bootstrap classloader是系统在启动jvm时默认加载的。
bootstrap classloader加载后，会载入extended classloader,并将extended classloader的父类
设为bootstrap classloader.
然后bootstrap classloader接着载入system classloader,并将system classloader父类设为extended 
classloader.至此bootstrap--extended--system三级继承结构形成。

类加载器的任务是将class二进制文件加载到方法区，供虚拟机模制出在堆中存放的对象。

classloader加载类的过程为：双亲委托机制
1.检查被加载类是否被加载
2.如果没有被加载，则调用父classloader加载该类。
3.如果1、2不成功，则由自身的类加载。
```
### 热修复，插件化
```
共同原理都是使用classloader来实现加载新的功能类，都可以使用PathClassloader与DexClassloader
不同是热修复是为了修复bug,将新的同名类替代同名的bug类。

插件化是增加新的功能或者资源文件，不涉及抢先加载旧的类这样的使用。

插件化比热修复简单，热修复是在插件化的基础上进行替换旧的Bug类。
```
###
```
```
###
```
```
###
```
```
###
```
```
