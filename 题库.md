### LruCache原理
[单一职责原则+开闭原则+LruCache实现ImageLoader](https://github.com/helloconch/Interview/tree/master/TIKU/app/src/main/java/com/conch/tiku/imageloader)


[原理详解](https://www.jianshu.com/p/b49a111147ee)
```
LRU(Least Recently Used)
LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。
LruCache内部使用LinkedHashMap进行数据存储,LinkedHashMap是由数组和双向链表的数据结构来实现。
双向链表结构可以实现访问顺序和插入顺序，使得LinkedHashMap<Key,Value>可以按照一定顺序排列起来。
通过构造函数 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
中的accessOrder区分是访问顺序还是插入顺序。accessOrder：true访问顺序，false为插入顺序。
LruCache中源码：
  public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }

put()方法，在添加缓存对象后，调用trimToSize()判断缓存是否已满，如果满了，则删除近期最少使用。
trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。
get()方法获取集合中缓存对象，将会更新队列，保持整个队列按照访问顺序排序。


```

### DiskLruCache解析
[详解](https://blog.csdn.net/guolin_blog/article/details/28863651)

### 图片加载原理
```
图片加载，首先是CPU计算出图像形状，完成之后，将图像交给GPU进行渲染，然后通过Dispay屏幕进行展示。
但是需要注意的一点，当CPU和GPU处理1帧图像时间超过16ms,那么这帧图像需要等到第2个VSync出现，
才能在屏幕进行显示，意味着32ms内所看到的是同1帧图像，产生所谓掉帧，也就是卡帧。

有几个因素使得CPU,GPU处理时间过长？
.过度绘制
2.动画使用次数过多
3.短时间创建对象过多（android垃圾回收机制，当heap被占用的空间达到一个阈值，GC开始回收对象，
GC回收时大部分线程是阻塞的，当GC耗时超过16ms，则出现失帧卡顿的现象）
```
### 模块化实现（好处、原因）
```
模块化是一种将复杂的系统分解为可管理模块的方式。
.模块间解耦(每个模块功能不同、业务逻辑不同、模块间业务解耦)
.提升开发效率(每个模块实际是一个项目，可以单独编译调试)
.多团队并行开发，测试。

模块化业务分层，从下到上
1.基础组件层(底层库和一些封装的libs)
2.业务组件层(支付、即时通信)
3.业务模块层(资讯模块、购物模块)


组件化是以重用化为目的，将一个系统拆分成一个个单独组件。
.避免重复造轮子，节省开发维护成本。
.降低项目复杂性，提升开发效率
.多个团队用同一个组件，在一定程度确保技术方案统一性。

```
### JVM
```
```
### 视频、文件加密传输

[详解](https://github.com/helloconch/Interview/blob/master/TIKU/app/src/main/java/com/conch/tiku/utils/FileEncryptAndDecrypt.java)

### 统计启动时长 标准
```
启动类型
1.冷启动，application没有被创建，需要先创建进程（fork一个新的进程，比较耗时），然后启动MainActivity.
2.热启动，已经启动过application,并驻留在系统内存内，只需要唤醒该进程，启动MainActivity

统计启动时间
1.物理统计：通过高速相机，从点击launcher图标开始，到MainActivity第一个可见帧，算启动时间
2.adb统计： adb shell am start -W package/xxx.MainActivity

启动流程：
1.点击桌面应用图标，launcher进程将启动的目标Activity的请求以Binder方式发送给AMS.
2.AMS收到请求后，以Socket方式请求Zygote进程
3.Zygote收到请求，fork出新进程。
4.在新进程中创建ActivityThread对象，新创建的进程就是应用的主线程，
在主线程里开启Looper消息循环，开始处理创建Activity
5.ActivityThread利用ClassLoader去加载Activity,创建Activity实例，并回调Activity
的onCreate().


```
### ThreadLocal原理
```
ThreadLocal用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)
时能保证各个线程里的变量相对独立于其他线程内的变量。

ThreadLocal设计思路：
每个ThreadLocal维护一个ThreadLocalMap映射表，这个映射表key为ThrealLocal本身，value是真正
需要存储的Object.

```
### 强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）
[详解](https://blog.csdn.net/mazhimazh/article/details/19752475)
### 谈谈classloader
```
jvm有三类classloader,分别为bootstrapclassloader,extendedclassloader以及systemclassloader.
bootstrap classloader是系统在启动jvm时默认加载的。
bootstrap classloader加载后，会载入extended classloader,并将extended classloader的父类
设为bootstrap classloader.
然后bootstrap classloader接着载入system classloader,并将system classloader父类设为extended 
classloader.至此bootstrap--extended--system三级继承结构形成。

类加载器的任务是将class二进制文件加载到方法区，供虚拟机模制出在堆中存放的对象。

classloader加载类的过程为：双亲委托机制
1.检查被加载类是否被加载
2.如果没有被加载，则调用父classloader加载该类。
3.如果1、2不成功，则由自身的类加载。
```
### 热修复，插件化
```
共同原理都是使用classloader来实现加载新的功能类，都可以使用PathClassloader与DexClassloader
不同是热修复是为了修复bug,将新的同名类替代同名的bug类。

插件化是增加新的功能或者资源文件，不涉及抢先加载旧的类这样的使用。

插件化比热修复简单，热修复是在插件化的基础上进行替换旧的Bug类。
```
### HashMap源码， SparseArray原理

[详解](https://www.jianshu.com/p/7b9a1b386265)
```
SparseArray采用2个数组，一个数组int[] mKeys存放key值，
因为key值为int，不需要hashcode操作，插入和查找基于二分法。
另一个数组int[] mValues存放值。

在数据量小的时候，一般为1000以下，当key值为int时候，使用SparseArray是一个不错
选择，相比较hashMap内存大概节省30% ,因为key值不需要进行装箱操作，所以性能较优。

```
### Collection的List ArrayList LinkedList
```
List(列表，线性顺序存储，可查找)
ArrayList（数组，中间插入删除慢，查找快）
LinkedList(链表，中间插入删除快，查找慢)

```
### map- HashMap Hashtable LinkedHashMap和TreeMap
```
HashMap：根据key的hashcode来存储数据，遍历时，取得数据随机，由于是线程不安全，
当需要同步时可用Collections.synchronizedMap()使HashMap具有同步能力，或者使用
ConcurrentHashMap，HashMap最多允许一条记录key=null,允许多条记录值为null.

HashTable:继承Dictionary类，线程安全，某一时刻只有一个线程写入，写入较慢，不允许键值为空.

LinkedHashMap：extends Hashmap，但它保存写入顺序，遍历时如果希望和写入顺序相同，可以考虑使用.

TreeMap:间接implements SortMap接口，能够把它保存的记录根据键排序，默认为升序排序，
也可以指定排序比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。


```

### HashMap、ConcurrentHashMap实现原理
[HashMap详解](http://www.importnew.com/16301.html)
[ConcurrentHashMap详解](https://blog.csdn.net/dingji_ping/article/details/51005799)

```
HashMap底层是一个数组结构，数组中的每一项是一个链表。
简单的说，HashMap在底层将key-value当成一个整体处理，这个整体就是一个Entry对象。HashMap
底层采用一个Entry[]数组来保存所有key-value对，当需要存储一个Entry对象时，会根据hash算法
来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置。

ConcurrentHashMap类创建16个并发的segment,每个segment里面包含多个Hash表，每个
Hash链都是有HashEntry节点组成。
HashTable是线程安全的，是因为将整张表加锁实现同步，一个缺陷是程序效率变得很低。
而ConcurrentHashMap将锁加在每个分段segment，这样我们队segment1操作的时候，
同时也可以对segment2的数据操作，这样效率会高很多。
```

### 性能优化，怎么保证应用启动不卡顿
[详解](https://blog.csdn.net/axi295309066/article/details/72675365)

```
应用在启动过程中，影响启动速度地方：
.Application的OnCreate
.首屏Activity的渲染

1.使用Traceview工具观察启动过程中方法耗时情况，重点关注onCreate()方法
2.分析自定义Application耗时操作，判断onCreate()方法中内容（如第三方工具是否可以不占用主线程进行初始化）
3.查看界面是否过度绘制
4.利用Hierarchy Viewer（层级）工具查看界面优化点
5.启动过程中的白屏优化
```

### 怎样去除重复代码
```
重构的主要任务是去除重复代码，有效的减少重复代码，提高软件的扩展性。
1.为项目定义一个基Activity或Fragment
2.代码的去重复技巧（如提炼方法，抽象基类）
3.用include减少局部布局重复
4.用ViewStub减少整体布局的重复

```
### 多进程共享数据方法
```
SharedPreferences(多进程模式)、广播、Socket、ContentProvider、Messenger、AIDL
Messager是一种轻量级IPC方案，底层实现原理就是AIDL，它对AIDL做了一次封装，它的效率比较低，
一次只能处理一次请求，所以不存在线程同步问题。
```

### SP是进程同步的吗？有什么方法做到同步
[详解](https://www.jianshu.com/p/bdebf741221e)
```
SP不能保证多进程间同步。
为了减少IO造成的性能损失，SP使用缓存机制，会将数据保持到内存中，
在读取的时候直接从内存获取，而写入的时候才保持到文件。如果多个进程都使用了普通的SP，
分别保存就会导致相互覆盖。

设置了MODE_MUTI_PROCESS之后，在多进程使用的时候，会在检测到文件变化时候，重新
加载文件到内存汇总，这样虽然损失一部分性能，却部分实现了多进程间同步。

为什么是部分实现多进程同步？当多个进程同时而又高频的调用commit方法时，就会导致文件
反复覆盖写入，而并没有被及时读取，造成进程间数据不同步。


通过ContentProvider进行实现多进程共享SP

```

### SurfaceView
[详解](https://blog.csdn.net/android_cmos/article/details/68955134)
```
SDK文档描述，SurfaceView就是在窗口里挖了一个洞，它显示在这个洞里，其他的View显示在
窗口上，所以view可以显示在surfaceview之上。surfaceview属于view的子类，是专门为制作
游戏产生，功能强大，最重要的是支付OPENGL ES库，2D,3D效果可以实现。创建SurfaceView时候
需要实现SurfaceHolder.Callback接口，它可以用来监听SurfaceView状态。

SurfaceView相当于另一个绘图线程，它是不会阻碍主线程，并且它在底层机制中实现双缓冲机制。


SurfaceView和View不同之处：
1.SurfaceView允许其它线程更新视图对象，而View不允许这么做，它只允许UI线程更新视图对象。
2.SurfaceView是放在其它最底层的视图层次中，所有其它视图都在它上面，所以在它之上可以添加一些层，
而且它不能是透明的。
3.它执行动画效率比View高，可以控制帧数。
4.SurfaceView在绘图的时使用双缓冲机制，而View没有。

```

### BroadcastReceiver、LocalBroadcastReceiver区别
```
BroadcastReceiver是跨应用广播，利用Binder机制实现。
LocalBroadcastReceiver是应用内广播，利用Handler实现，利用IntentFilter的match功能，
提供信息的发送与接收,效率比较高。

```


### Bundle机制
```
Bundle实现Parcelable接口，支持进程间通讯，保存特定数据。
```


### Handler机制
```
1.Handler通过sendMessage()发送消息message到消息队列MessageQueue.
2.Looper通过loop()不断提取触发条件message,并将message交给对应的target handler处理
3.target handler调用自身handleMessage()方法来处理Message

```


### Android事件传递机制
[详解](https://blog.csdn.net/carson_ho/article/details/54136311)
```
public boolean dispatchTouchEvent(MotionEvent ev){
  boolean consume = false;
  if(onInterceptTouchEvent(ev)){
      consume=onTouchEvent(ev);
 }else{
      consume=child.dispatchTouchEvent(ev);
  }
  return consume;
}
对于一个根ViewGroup来说，点击事件产生后，首先会调用它，这时它的dispatchTouchEvent就会调用，
如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示他要拦截当前事件，
接着这个ViewGroup的onTouchEvent方法就会调用
（这里默认它没设置OnTouchListener，具体为什么，这里先不讲），
如果onInterceptTouchEvent返回false，就表示它不拦截当前事件，
这时事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，
然后继续上述过程，直到事件被处理。


```


### java synchronized对象锁和类锁的区别
[详解](https://blog.csdn.net/zhujiangtaotaise/article/details/55509939)
```
synchronized加到static方法前面是给class加锁，即类锁。
1.对象锁和类锁是不同的锁，所以多个线程执行2个不同的锁的方法是，是异步操作。
2.类锁对该类的所有对象都能起作用，而对象锁不能。
```


### 动态加载、静态类加载
```
编译时加载是静态加载类。
运行时加载为动态加载类。
在日常中我们希望用到哪个就加载哪个，不用不加载，就需要动态加载类。
使用动态加载类时，我们不用定义100种功能，只需要通过实现某种标准（实现某个接口）。
public class Main{  
    public static void main(String args[]){  
        try{  
              
            Class c=Class.forName(args[0]);  
          
            All a=(All)c.newInstance();  
            a.start();  
        }catch(Exception e){  
            e.printStackTrace();  
        }  
    }  
}  
class A implements All{  
    public void start(){  
        System.out.println("A....START");  
    }  
}  
class B implements All{  
    public void start(){  
        System.out.println("B....START");  
    }  
}  
//接口  
interface All{  
    public void start();  
}

```


### GC回收策略
```
当系统空闲或者发起System.GC操作时，
从GC root开始搜索，搜索不到对象，经过第一次标记，清理后，仍然没有复活的对象。

```

### Android的大体架构图
```
Android系统架构图，从上往下
1.应用程序层
2.应用程序框架层
3.系统库和Android运行时
4.Linux内核
```

### Android Studio的build按钮后发生什么
```
build过程将资源和代码文件打包成apk
1.通过appt工具，将资源文件生成R.java文件，将aidl文件转化为对应java文件
2.编译java文件，生成.class文件
3.将.class文件转化为Android虚拟机支持的.dex文件
4.通过apkbuilder将dex文件和编译后的资源文件生成apk文件
5.对apk进行签名和对齐
```

### 大体说一下应用程序安装到手机发生了什么
```
1.复制apk到/data/app目录下，解压并扫描安装包
2.资源管理器解析apk里的资源文件
3.解析AndroidManifest清单文件，并在data/data/目录下创建对应的应用数据目录
4.对dex文件进行优化，并保持在dalvik-cache目录下
5.将AndroidManifest文件解析出的四大组件信息注册到PackManagerService中
6.安装完成后，发送广播

```

### JVM/Dalvik/ART 虚拟机有基本的了解
```
JVM运行在操作系统上，是一种基于栈结构，java编译后的字节码在JVM上运行，
jvm屏蔽底层实现，由它把字节码翻译成机器指令。

DVM:Dalvik Virtual Machine安卓虚拟机，基于寄存器结构，每一个应用都对应一个Dalvik虚拟机实例。
DVM通过解释DEX文件来执行这些字节码。

ART:安装应用时，dex中的字节码将被编译为本地机器码，之后每次打开应用，执行都是本地机器码，
移除运行时解释执行，效率更高，启动更快。
```
### Android上的IPC跨进程通信如何工作
```
Android各种IPC方式Bundle、使用文件共享、使用Messenger、使用AIDL、使用ContentProvider、使用Socket、Binder
```

### APP是如何沙箱化，为什么要这么做
```
Android“沙箱”的本质是为了实现不同应用程序和进程之间的互相隔离，
即在默认情况 下，应用程序没有权限访问系统资源或其它应用程序的资源。
每个APP和系统进程都被分配唯一并且固定的User Id，这个uid与内核层进程的uid对应。
每个APP在各自独立的Dalvik虚拟机中运行，拥有独立的地址空间和资源。
运行于Dalvik虚拟机中的 进程必须依托内核层Linux进程而存在，
因此Android使用Dalvik虚拟机和Linux的文件访问控制来实现沙箱机制，
任何应用程序如果想要访 问系统资源或者其它应用程序的资源必须在自己的manifest文件中进行声明权限或者共享uid.

```
### recycleView 、listview区别，性能
```
从布局层面来讲：recycleview支持线性布局、网格布局、瀑布流布局，而且还支持横向还是纵向滚动。
从API角度：recycleview提供大量API供开发者使用如：布局管理器LayoutManager,局部刷新notifyItemChanged
动画效果等。

```
### 快速排序的实现
```
快速排序相比冒泡排序，每次交换是跳跃式的。每次排序的时候，设置一个基准点，
将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边，
每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了，
因此总的比较和交换次数就少，速度自然就提高。其实快速排序基于一种“二分”思想。
```
### synchronized与Lock的区别 
[详解](https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&fps=1)
```
线程5种状态
1.新建状态：新建线程对象，并没有调用start()方法之前
2.就绪状态:调用start()方法线程就进入就绪状态，但不一定运行，线程
睡眠和挂起中恢复的时候也会进入到就绪状态。
3.运行状态：线程被设置为当前线程，开始执行run()方法。
4.阻塞状态：线程被暂停，调用sleep()方法后线程进入阻塞状态
5.死亡状态：线程执行结束。


二者区别：
1.synchronzied属于java关键字，在JVM层面，而Lock是一个类
2.锁的释放前者在获取锁的线程执行完同步代码，就会释放锁，
而Lock在finally中必须释放锁，不然容易造成线程死锁。
3.锁的状态，synchronzied无法判断，而Lock是可以判断的
4.性能上synchronzied可少量同步，后者Lock大量同步

```

### TCP、UDP区别
[详解](https://blog.csdn.net/li_ning_/article/details/52117463)
### TCP、UDP区别
```
TCP连接需要经过3次握手
1.客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。
2.服务器收到syn包，必须确认客户的SYN(ack=j+1),同时发送自己的SYN(syn=k),
SYN+ACK包，此时服务器进行SYN_REV状态。
3.客户端收到服务器SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，
和服务器进入ESTABLISHED状态，完成三次握手。

断开过程需要经过4次握手

区别:
1.基于连接与无连接
2.TCP要求系统资源多，UDP较少
3.UDP程序结构较简单
4.流模式(TCP)与数据报模式(UDP)
5.TCP保证数据正确性，UDP可能丢包
6.TCP保证数据顺序，UDP不保证

UDP应用场景
1.面向数据报方式
2.网络数据大多为短消息
3.拥有大量Client
4.对数据安全性无特殊要求
5.网络负担非常重，但对响应速度要求高




```

### Http与Socket区别
[详解](https://blog.csdn.net/fulai00/article/details/46491749)
```
Http在每次请求结束后都会主动释放连接，因此HTTP连接是一种"短链接"，要保持客户端
的在线状态，需要不断地向服务器发起连接请求。


Socket：套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议(TCP/UDP)
当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
```
### volatile
```
volatile让变量每次在使用的时候，都从主存取。而不是从各个线程的“工作内存”；
volatile具有synchronized关键字的"可见性"，但是没有synchronized关键字"并发正确性"，
并不保证线程执行的有序性。
volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但volatile并不能保证
并发的正确性。
```
### java线程池
```
如果并发线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，
这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。
通过线程池解决这个问题。

```
### java中对象和类的生命周期
[详解](https://blog.csdn.net/huangzhen0914/article/details/45172597)
```
对象的生命周期大致分7个阶段
1.创建阶段
2.应用阶段
3.不可视阶段
4.不可到达阶段
5.可收集阶段
6.终结阶段
7.释放阶段
对象生命周期最后一个阶段是可收集阶段，终结阶段与释放阶段。
当对象处于这个阶段时候，可能处于下面3种情况：
a)垃圾回收器发现该对象已经不可达
b)finalize方法已经被执行
c)对象空间已被重用


类的生命周期

加载-连接-初始化-使用-卸载

```
### 类的加载机制
[详解](https://www.cnblogs.com/ityouknow/p/5603287.html)
```
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区
的方法区内，然后在堆区创建一个java.class.Class对象，用来封装方法区的数据结构。
```
### MVP模式/MVC模式
```
MVP:Model/View/Presenter
MVC:Model/View/Controller

两者最明显区别：MVC是允许Model和View进行交互。
MVP中，Model与View之间交互由Presenter完成,还有一点
Presenter与View之间交互通过接口。
```
### RXJava
```
```
### 抽象类和接口区别
```
1.前者可以有默认的方法实现，候着不存在方法实现。
2.前者子类通过extends方式继承抽象类，后者通过implements方式实现接口
3.抽象类可以有构造器，接口不能
4.抽象类不能被实例化，接口也是不能
5.抽象类可以继承一个类实现多个接口，接口只能继承一个或多个接口
6.抽象类比接口速度快，接口稍微慢，它需要时间去寻找类中实现的方法。
```
### 集合Set实现Hash 怎么防止碰撞
```
```
###
```
```
###
```
```
