#### 接口的意义
```
规范、利于扩展
```
#### 接口与抽象类区别
```
1.接口中所有方法都是抽象的，而抽象类中可以有非抽象方法。
2.接口中所有非方法和属性都是Public类型，而抽象类中可以有Private类型。
3.普通类实现接口的话，要实现接口里所有的方法。但普通类定义为抽象类时，可以选择性实现或不实现接口里的方法。
4.普通类继承抽象类的话，要实现抽象类里得所有抽象方法。但普通类定义为抽象类，继承抽象类，可以选择性实现抽象类的抽象方法。
5.普通类可以实现多个接口,普通类只能继承一个抽象类。接口可以继承多个接口。
6.抽象类和接口无法自己进行实例化

接口是对动作的抽象，而抽象类是对根源的抽象。对于抽象类，比如男人，女人这两个类，
那我们可以为这两个类设计一个更高级别的抽象类--人。
对于接口，我们可以坐着吃饭，可以站着吃饭，可以用筷子吃饭，可以用叉子吃饭，甚至可以学三哥一样用手抓着吃饭，
那么可以把这些吃饭的动作抽象成一个接口--吃饭。所以在高级语言中（如Java,C#），
一个类只能继承一个抽象类（因为你不可能同时是生物又是非生物）。
但是一个类可以同时实现多个接口，比如开车接口，滑冰接口，啪啪啪接口，踢足球接口，游泳接口。

```
#### 抽象类的意义
```
1.为子类提供一个公共的类型。
2.抽象类更利于代码的维护和重用。
```
#### 内部类的作用
```
1.内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
3.创建内部类对象的时刻并不依赖于外围类对象的创建。
4.内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
5.内部类提供了更好的封装，除了该外围类，其他类都不能访问
```

#### 父类的静态方法能否被子类重写
```
不能
```
[java排序算法](http://blog.csdn.net/qy1387/article/details/7752973)


#### 列举java的集合和继承关系
```
Collection->List(LinkedList,ArrayList,Vector(->Stack))
Collection->Set
Map->Hashtable
Map->HashMap
Map->WeakHashMap

```

####java虚拟机的特性
```
java语言特点就是与平台的无关性，java虚拟机是实现这一特性的关键所在。
一般高级语言想在不同平台进行运行，至少需要编译不同的目标代码。
而引入java虚拟机，java语言在不同平台则不需要重新编译。
java虚拟机在执行字节码时，把字节码解释成具体平台的机器指令执行。
```

####哪些情况下的对象会被垃圾回收机制处理掉
```
垃圾回收基本做法是分代回收。内存区域被划分为不同时代（年轻、年老、永久）。
对象根据其存活时间被保存在不同的时代中。当一个对象存活时间足够长，将被复制年老时代。
每个时代可以使用不同的垃圾回收算法。
```

####进程和线程的区别
```
一个应用程序至少有一个进程，一个进程至少有一个线程。
线程的划分尺度小于进程，使得多线程程序并发性高。
进程在执行过程中拥有独立的内存单元，而多线程共享内存，极大提高程序运行效率。
线程不能独立运行，必须依存在应用程序中。

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，
所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
```

####java中==和equals和hashCode的区别
```
1.java的基本数据类型，也称为原始的数据类型。它们分别是： 
byte, short, char, int, long, float, double, boolean . 
基本数据类型进行 “==” 比较时，比较的是 它们的值是否相同，无equals方法。

2.当 两个对象使用 “==” 进行比较时，比较的是它们在 内存中存放的地址。
也就是说，除非是 同一个new() 出来的两个对象(内存地址相同)， 否则比较的结果都是false。

3.默认情况下，当我们调用equals() 方法时，也仍然是比较两个对象 是否指向同一块内存空间。 

4.诡异的String 
String c="CCCCCC";
String c1=c;
System.out.println(c==c1);
System.out.println(c.equals(c1));
		
String c2="CCCCCC";
System.out.println(c==c2);
System.out.println(c.equals(c2));
true
true
true
true

```

####HashMap的实现原理
```
HashMap是基于哈希表Map接口的非同步实现。可以存在null-null组合，并且不保证存储顺序不变。
在java语言中，最基本的结构就是2种，1种是数组，另一种是模拟指针。
所有的数据结构，都可以用这2个基本的结构来构造，HashMap也不例外，
HashMap是一个“链表散列”的数据结构，即数组+链表结构，
HashMap底层是一个数组结构，每一个数组项是一个链表。
```

####int-char-long各占多少字节数
```
      位数   字节数
byte   8      1

short  16     2

int    32     4

long  64      8

float 32      4

double 64     8

char 16       2
```

####java int与integer的区别
```
从大的方面区别int是基本数据类型，integer是包装类。
int基本类型，直接存值，integer是对象，用一引用指向这个对象。
```


####string-stringbuffer-stringbuilder区别
```
String 字符串常量

StringBuffer 字符串变量（线程安全）

StringBuilder 字符串变量（非线程安全）
```

####java多态
```
面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。
多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。
多态的作用：消除类型之间的耦合关系。
现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS3 的帮助文档；
如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。
多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。
Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。
```
####什么导致线程阻塞
```
阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪）,Java 提供了大量方法来支持阻塞，下面让我们逐一分析。
1.sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，
不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：
测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。
2.suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，
必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。
典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，
另一个线程产生了结果后，调用 resume() 使其恢复。
3.yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，
随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.
4.wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，
它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，
前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.
它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。
区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。

```
####Java中hashmap和hashtable的区别
```
1、 继承和实现区别
　　Hashtable是基于陈旧的Dictionary类，完成了Map接口；
  HashMap是Java 1.2引进的Map接口的一个实现（HashMap继承于AbstractMap,AbstractMap完成了Map接口）。
　　2、 线程安全不同
　　HashTable的方法是同步的，HashMap是未同步，所以在多线程场合要手动同步HashMap。
　　3、 对null的处理不同
　　HashTable不允许null值(key和value都不可以),HashMap允许null值(key和value都可以)。
   即 HashTable不允许null值其实在编译期不会有任何的不一样，会照样执行，只是在运行期的时候Hashtable中设置的话回出现空指针异常。
   HashMap允许null值是指可以有一个或多个.
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
####
```
```
